<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>CycleDash VisibilityPro</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>

    <style>
        :root { --sat: env(safe-area-inset-top, 0px); --sab: env(safe-area-inset-bottom, 0px); }
        body, html { margin: 0; padding: 0; height: 100svh; width: 100%; overflow: hidden; background: #1a1a1a; font-family: -apple-system, system-ui, sans-serif; }
        #container { display: flex; flex-direction: column; height: 100svh; width: 100vw; }
        
        #hud-header { background: #222; color: white; padding-top: var(--sat); display: grid; grid-template-columns: 1fr 1fr; border-bottom: 1px solid #444; flex-shrink: 0; z-index: 1000; }
        .hud-column { display: flex; flex-direction: column; padding: 8px 12px; }
        .data-row { display: flex; justify-content: space-between; align-items: baseline; border-bottom: 1px solid #333; padding: 2px 0; }
        .label { font-size: 10px; font-weight: bold; color: #888; }
        .val-text { font-size: 20px; font-weight: bold; font-family: monospace; color: #fff; }

        #map { flex: 1; background: #111; position: relative; width: 100%; z-index: 1; }
        #bottom-tray { display: flex; height: 150px; background: white; border-top: 2px solid #333; padding-bottom: var(--sab); flex-shrink: 0; width: 100%; z-index: 1000;}
        
        #chart-section { flex: 1; min-width: 0; position: relative; padding: 5px; height: 100%; }
        #action-section { flex: 0 0 90px; display: flex; flex-direction: column; justify-content: space-evenly; align-items: center; background: #ececec; border-left: 1px solid #ccc; }
        
        .action-btn { font-size: 10px; cursor: pointer; text-align: center; width: 80px; padding: 10px 0; background: #fff; border: 1px solid #999; border-radius: 4px; font-weight: bold; color: #333; }
        #recenter-btn { background: #3498db; color: white; border: none; display: none; position: absolute; top: 10px; right: 10px; z-index: 2000; width: auto; padding: 8px 15px; }
        #reset-btn { background: #fee; color: #c0392b; border: 1px solid #fcc; }
        
        #status { position: absolute; bottom: 8px; left: 8px; z-index: 2000; font-size: 10px; color: #2ecc71; text-shadow: 1px 1px 1px #000; font-weight: bold; }
        canvas { width: 100% !important; height: 100% !important; }
    </style>
</head>
<body>

<div id="container">
    <div id="hud-header">
        <div class="hud-column">
            <div class="data-row"><span class="label">MPH</span><span class="val-text" id="speed-val">0.0</span></div>
            <div class="data-row"><span class="label">REMAIN</span><span class="val-text" id="remain-val">0.0</span></div>
        </div>
        <div class="hud-column">
            <div class="data-row"><span class="label">ELEV</span><span class="val-text" id="elev-val">---</span></div>
            <div class="data-row"><span class="label">GRADE</span><span class="val-text" id="grade-val">0.0</span></div>
        </div>
    </div>

    <div id="map">
        <div id="status">GPS: WAITING</div>
        <button class="action-btn" id="recenter-btn">RESUME TRACKING</button>
    </div>

    <div id="bottom-tray">
        <div id="chart-section"><canvas id="elevationChart"></canvas></div>
        <div id="action-section">
            <label class="action-btn">KML <input type="file" id="kml-upload" accept=".kml" style="display:none"></label>
            <button class="action-btn" id="fs-btn">FULL</button>
            <button class="action-btn" id="reset-btn">RESET</button>
        </div>
    </div>
</div>

<script>
    let map, chart, userMarker, snappedMarker, startMarker, endMarker, breadcrumbLine, routeGeoJson, kmlRouteLine;
    let isFollowing = true, totalDist = 0, routeData = [], breadcrumbCoords = [];
    let lastLat, lastLng;
    const METERS_TO_FEET = 3.28084, MPS_TO_MPH = 2.23694, FEET_LIMIT = 500, WINDOW_MI = 0.25;

    function init() {
        map = L.map('map', { zoomControl: false }).setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png').addTo(map);

        // Pre-initialize markers so they exist in the DOM/Map layers immediately
        breadcrumbLine = L.polyline([], { color: '#3498db', weight: 5, opacity: 0.6 }).addTo(map);
        
        // Marker styles
        const markerBase = { fillOpacity: 1, stroke: true, weight: 2, color: '#fff' };
        startMarker = L.circleMarker([0,0], { ...markerBase, fillColor: '#2ecc71', radius: 8 }).addTo(map);
        endMarker = L.circleMarker([0,0], { ...markerBase, fillColor: '#e74c3c', radius: 8 }).addTo(map);
        snappedMarker = L.circleMarker([0,0], { ...markerBase, fillColor: '#f39c12', radius: 6 }).addTo(map);
        userMarker = L.circleMarker([0,0], { ...markerBase, fillColor: '#3498db', radius: 10 }).addTo(map);

        const ctx = document.getElementById('elevationChart').getContext('2d');
        chart = new Chart(ctx, {
            type: 'line',
            data: { datasets: [
                { id: 'route', data: [], borderWidth: 2, pointRadius: 0, tension: 0.1, segment: { borderColor: ctx => {
                    const p1 = ctx.p0.raw, p2 = ctx.p1.raw;
                    if (!p1 || !p2) return '#27ae60';
                    const grade = ((p2.y - p1.y) / ((p2.x - p1.x) * 5280)) * 100;
                    return grade >= 6 ? '#e74c3c' : (grade >= 3 ? '#f1c40f' : '#27ae60');
                }}}, 
                { id: 'user-pos', data: [], pointRadius: 7, pointBackgroundColor: '#f39c12', pointBorderColor: '#fff', pointBorderWidth: 2, showLine: false }
            ]},
            options: { 
                responsive: true, maintainAspectRatio: false, 
                plugins: { legend: false },
                scales: { 
                    x: { type: 'linear', ticks: { display: false }, grid: { display: false } }, 
                    y: { grace: '15%', ticks: { font: { size: 9 } } } 
                } 
            }
        });

        document.getElementById('fs-btn').onclick = () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => {});
            else document.exitFullscreen();
        };

        map.on('dragstart', () => {
            isFollowing = false;
            document.getElementById('recenter-btn').style.display = 'block';
        });

        document.getElementById('recenter-btn').onclick = () => {
            isFollowing = true;
            document.getElementById('recenter-btn').style.display = 'none';
            if(lastLat && lastLng) map.setView([lastLat, lastLng], 16);
        };

        window.addEventListener('resize', () => { 
            setTimeout(() => { map.invalidateSize(); chart.resize(); chart.update('none'); }, 200); 
        });

        document.getElementById('reset-btn').onclick = () => { localStorage.clear(); location.reload(); };
        document.getElementById('kml-upload').onchange = (e) => {
            const reader = new FileReader();
            reader.onload = (ev) => { 
                localStorage.setItem('cycling_kml_foss', ev.target.result); 
                loadKml(ev.target.result); 
            };
            reader.readAsText(e.target.files[0]);
        };

        const saved = localStorage.getItem('cycling_kml_foss');
        if (saved) loadKml(saved);
        startGPS();
    }

    function getElevAtDist(targetDist) {
        if (routeData.length === 0) return 0;
        const target = Math.max(0, Math.min(targetDist, totalDist));
        for (let i = 0; i < routeData.length - 1; i++) {
            if (target >= routeData[i].x && target <= routeData[i+1].x) {
                const ratio = (target - routeData[i].x) / (routeData[i+1].x - routeData[i].x);
                return routeData[i].y + ratio * (routeData[i+1].y - routeData[i].y);
            }
        }
        return routeData[routeData.length - 1].y;
    }

    function startGPS() {
        navigator.geolocation.watchPosition((pos) => {
            const { latitude: lat, longitude: lng, speed, altitude } = pos.coords;
            lastLat = lat; lastLng = lng;
            const curElev = altitude ? Math.round(altitude * METERS_TO_FEET) : 0;
            
            document.getElementById('status').innerText = "GPS: OK";
            document.getElementById('speed-val').innerText = speed ? (speed * MPS_TO_MPH).toFixed(1) : "0.0";
            document.getElementById('elev-val').innerText = curElev || "---";
            
            userMarker.setLatLng([lat, lng]);
            breadcrumbCoords.push([lat, lng]);
            breadcrumbLine.setLatLngs(breadcrumbCoords);

            if (isFollowing) map.setView([lat, lng], map.getZoom() < 10 ? 16 : map.getZoom());

            if (routeGeoJson) {
                const userPt = turf.point([lng, lat]);
                const snapped = turf.nearestPointOnLine(routeGeoJson, userPt, {units: 'miles'});
                const curDist = snapped.properties.location;

                // Update Snapped Marker
                snappedMarker.setLatLng([snapped.geometry.coordinates[1], snapped.geometry.coordinates[0]]);

                // Grade Calculation
                const step = 0.01; 
                const e1 = getElevAtDist(curDist);
                const e2 = getElevAtDist(curDist + step);
                const grade = ((e2 - e1) / (step * 5280)) * 100;
                
                const gradeEl = document.getElementById('grade-val');
                gradeEl.innerText = isFinite(grade) ? grade.toFixed(1) : "0.0";
                gradeEl.style.color = grade >= 6 ? "#e74c3c" : (grade >= 3 ? "#f1c40f" : "#fff");
                document.getElementById('remain-val').innerText = Math.max(0, totalDist - curDist).toFixed(1);

                // Update Chart
                const minX = curDist - WINDOW_MI, maxX = curDist + WINDOW_MI;
                chart.options.scales.x.min = minX;
                chart.options.scales.x.max = maxX;
                chart.data.datasets[1].data = [{ x: curDist, y: curElev || e1 }];
                
                const visible = routeData.filter(p => p.x >= minX && p.x <= maxX);
                if (visible.length > 0) {
                    const eArr = visible.map(p => p.y);
                    chart.options.scales.y.min = Math.min(...eArr) - 30;
                    chart.options.scales.y.max = Math.max(...eArr) + 30;
                }
                chart.update('none');
            }
        }, (err) => { document.getElementById('status').innerText = "GPS: ERROR"; }, { enableHighAccuracy: true });
    }

    function loadKml(xmlString) {
        try {
            const geojson = toGeoJSON.kml(new DOMParser().parseFromString(xmlString, "text/xml"));
            const line = geojson.features.find(f => f.geometry.type === 'LineString');
            if (!line) return;
            
            const raw = line.geometry.coordinates;
            const smoothed = raw.map((c, i) => {
                const win = raw.slice(Math.max(0, i-2), Math.min(raw.length, i+3));
                const avg = win.reduce((sum, pt) => sum + (pt[2] || 0), 0) / win.length;
                return [c[0], c[1], avg * METERS_TO_FEET];
            });

            routeGeoJson = { type: "Feature", geometry: { type: "LineString", coordinates: smoothed } };
            
            let d = 0; routeData = [{x:0, y:smoothed[0][2]}];
            for(let i=1; i<smoothed.length; i++) {
                d += turf.distance(turf.point(smoothed[i-1]), turf.point(smoothed[i]), {units:'miles'});
                routeData.push({x: d, y: smoothed[i][2]});
            }
            totalDist = d;

            // Set Start/End Marker positions
            startMarker.setLatLng([smoothed[0][1], smoothed[0][0]]);
            endMarker.setLatLng([smoothed[smoothed.length-1][1], smoothed[smoothed.length-1][0]]);

            chart.data.datasets[0].data = routeData;
            chart.update();

            if (kmlRouteLine) map.removeLayer(kmlRouteLine);
            kmlRouteLine = L.polyline(smoothed.map(c => [c[1], c[0]]), { 
                color: '#000000', weight: 3, opacity: 0.8, dashArray: '8, 12'
            }).addTo(map);

            map.fitBounds(kmlRouteLine.getBounds());
            setTimeout(() => { map.invalidateSize(); }, 500);

        } catch(e) { console.error("KML Parse Error", e); }
    }
    window.onload = init;
</script>
</body>
</html>

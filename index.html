<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>CycleDash GradePro</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>

    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #1a1a1a; font-family: sans-serif; }
        #container { display: flex; flex-direction: column; height: 100vh; height: -webkit-fill-available; }
        #map { flex: 3; z-index: 1; }
        #chart-container { flex: 1; background: white; border-top: 2px solid #333; padding: 5px; box-sizing: border-box; }
        
        #ui-left, #ui-right { 
            position: absolute; 
            top: env(safe-area-inset-top, 10px); 
            z-index: 1000; 
            display: flex; 
            flex-direction: column; 
            gap: 2px; 
        }
        #ui-left { left: 8px; }
        #ui-right { right: 8px; align-items: flex-end; }
        
        .btn, .data-box { 
            background: rgba(255, 255, 255, 0.3); 
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1px 4px; 
            border-radius: 3px; 
            font-weight: bold; 
            color: #000;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            text-transform: uppercase;
            box-sizing: border-box;
        }

        .btn { font-size: 11px; cursor: pointer; }
        .data-box { min-width: 72px; width: fit-content; text-align: right; transition: background 0.3s; margin-bottom: 1px; overflow: hidden; }
        .val-text { font-size: 14.5px; display: block; line-height: 1; letter-spacing: normal; } 
        .label { font-size: 6.5px; display: block; opacity: 0.9; margin-bottom: 1px; white-space: nowrap; }

        #recenter-btn { background: rgba(52, 152, 219, 0.3); color: white; display: none; }
        #reset-btn { background: rgba(231, 76, 60, 0.3); color: white; }
        #status { color: white; position: absolute; bottom: 26%; left: 8px; z-index: 1000; font-size: 7px; opacity: 0.4; }
    </style>
</head>
<body>

<div id="container">
    <div id="ui-left">
        <label class="btn">KML <input type="file" id="kml-upload" accept=".kml" style="display:none"></label>
        <button class="btn" id="fullscreen-btn">FULL</button>
        <button class="btn" id="recenter-btn">RESUME</button>
        <button class="btn" id="reset-btn">RESET</button>
    </div>

    <div id="ui-right">
        <div class="data-box"><span class="label">SPEED (mph)</span><span class="val-text" id="speed-val">0.0</span></div>
        <div class="data-box"><span class="label">ELEV (ft)</span><span class="val-text" id="elev-val">0</span></div>
        <div id="grade-box" class="data-box"><span class="label">GRADE (%)</span><span class="val-text" id="grade-val">0.0</span></div>
        <div class="data-box"><span class="label">REMAIN (mi)</span><span class="val-text" id="remain-val">0.0</span></div>
    </div>

    <div id="status">WAITING...</div>
    <div id="map"></div>
    <div id="chart-container"><canvas id="elevationChart"></canvas></div>
</div>

<script>
    let map, chart, userMarker, snappedMarker, trailLine, kmlRouteLine, routeGeoJson;
    let startMarker, endMarker;
    let breadcrumbs = [], isFollowing = true, currentDist = 0, totalDist = 0, chartZoomRadius = 0.5;

    const METERS_TO_FEET = 3.28084;
    const MPS_TO_MPH = 2.23694;
    const FEET_LIMIT = 500;

    function init() {
        map = L.map('map', { zoomControl: false, tap: false }).setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png').addTo(map);

        userMarker = L.circleMarker([0,0], { color: '#2ecc71', fillColor: '#27ae60', fillOpacity: 0.6, radius: 6 }).addTo(map);
        snappedMarker = L.circleMarker([0,0], { 
            color: '#e67e22', fillColor: '#d35400', fillOpacity: 1, radius: 8, pane: 'markerPane' 
        }).addTo(map);

        setTimeout(() => { if(snappedMarker.getElement()) snappedMarker.getElement().style.zIndex = "1000"; }, 100);

        trailLine = L.polyline([], { color: '#3498db', weight: 3, opacity: 0.5 }).addTo(map);

        chart = new Chart(document.getElementById('elevationChart'), {
            type: 'line',
            data: { 
                datasets: [
                    { data: [], borderWidth: 3, pointRadius: 0, tension: 0.1, segment: { borderColor: ctx => {
                        const p1 = ctx.p0.raw, p2 = ctx.p1.raw;
                        if (!p1 || !p2) return '#27ae60';
                        const dx = (p2.x - p1.x) * 5280, dy = p2.y - p1.y;
                        const grade = (dx > 0) ? (dy / dx) * 100 : 0;
                        // NEW Thresholds: >6% Red, >3% Yellow, Else Green
                        if (grade >= 6) return '#e74c3c';
                        if (grade >= 3) return '#f1c40f';
                        return '#27ae60';
                    }}}, 
                    { data: [], pointRadius: 8, pointBackgroundColor: '#e67e22', pointBorderColor: '#fff', pointBorderWidth: 2, showLine: false }
                ] 
            },
            options: { 
                responsive: true, maintainAspectRatio: false, 
                plugins: { legend: false }, 
                scales: { 
                    x: { type: 'linear', ticks: { font: { size: 8 } } }, 
                    y: { ticks: { font: { size: 8 } } } 
                } 
            }
        });

        map.on('moveend', () => {
            const bounds = map.getBounds();
            const mapWidthMiles = turf.distance(
                turf.point([bounds.getWest(), map.getCenter().lat]), 
                turf.point([bounds.getEast(), map.getCenter().lat]), 
                {units: 'miles'}
            );
            chartZoomRadius = mapWidthMiles / 2;
            updateChartWindow();
        });

        map.on('movestart', (e) => { if (!e.hard) { isFollowing = false; document.getElementById('recenter-btn').style.display = 'block'; } });
        document.getElementById('recenter-btn').onclick = () => { isFollowing = true; document.getElementById('recenter-btn').style.display = 'none'; };

        const saved = localStorage.getItem('cycling_kml_foss');
        navigator.geolocation.getCurrentPosition((pos) => {
            if (saved) loadKml(saved); 
            else map.fitBounds(L.latLng(pos.coords.latitude, pos.coords.longitude).toBounds(1000));
        });

        document.getElementById('fullscreen-btn').onclick = () => {
            if (!document.fullscreenElement) { document.documentElement.requestFullscreen(); }
            else { document.exitFullscreen(); }
        };

        document.getElementById('kml-upload').onchange = (e) => {
            const reader = new FileReader();
            reader.onload = (ev) => { localStorage.setItem('cycling_kml_foss', ev.target.result); loadKml(ev.target.result); };
            reader.readAsText(e.target.files[0]);
        };

        document.getElementById('reset-btn').onclick = () => { localStorage.removeItem('cycling_kml_foss'); location.reload(); };

        startGPS();
    }

    function loadKml(xmlString) {
        const geojson = toGeoJSON.kml(new DOMParser().parseFromString(xmlString, "text/xml"));
        const line = geojson.features.find(f => f.geometry.type === 'LineString');
        if (!line) return;

        const rawCoords = line.geometry.coordinates;
        const windowSize = 4;
        const smoothedCoords = rawCoords.map((c, i) => {
            let sumElev = 0, count = 0;
            for (let j = i - windowSize; j <= i + windowSize; j++) {
                if (j >= 0 && j < rawCoords.length) { sumElev += (rawCoords[j][2] || 0); count++; }
            }
            return [c[0], c[1], (sumElev / count) * METERS_TO_FEET];
        });

        routeGeoJson = { type: "Feature", geometry: { type: "LineString", coordinates: smoothedCoords } };

        let dist = 0, chartPoints = [];
        smoothedCoords.forEach((c, i) => {
            if (i > 0) dist += turf.distance(turf.point(smoothedCoords[i-1]), turf.point(c), {units: 'miles'});
            chartPoints.push({ x: dist, y: c[2] });
        });

        totalDist = dist;
        chart.data.datasets[0].data = chartPoints;
        chart.update();

        if (kmlRouteLine) map.removeLayer(kmlRouteLine);
        kmlRouteLine = L.polyline(smoothedCoords.map(c => [c[1], c[0]]), { color: '#000', weight: 2, opacity: 0.4, dashArray: '5, 5' }).addTo(map);

        if (startMarker) map.removeLayer(startMarker);
        if (endMarker) map.removeLayer(endMarker);
        const startPt = [smoothedCoords[0][1], smoothedCoords[0][0]];
        const endPt = [smoothedCoords[smoothedCoords.length - 1][1], smoothedCoords[smoothedCoords.length - 1][0]];
        startMarker = L.circleMarker(startPt, { radius: 7, color: '#27ae60', weight: 2, fillOpacity: 0.8, pane: 'markerPane' }).addTo(map);
        endMarker = L.circleMarker(endPt, { radius: 7, color: '#e74c3c', weight: 2, fillOpacity: 0.8, pane: 'markerPane' }).addTo(map);

        map.fitBounds(kmlRouteLine.getBounds(), { padding: [20, 20] });
    }

    function updateChartWindow() {
        if (!routeGeoJson) return;
        chart.options.scales.x.min = Math.max(0, currentDist - chartZoomRadius);
        chart.options.scales.x.max = Math.max(chartZoomRadius * 2, currentDist + chartZoomRadius);
        chart.update('none');
    }

    function startGPS() {
        navigator.geolocation.watchPosition((pos) => {
            const { latitude: lat, longitude: lng, speed, altitude } = pos.coords;
            document.getElementById('speed-val').innerText = speed ? (speed * MPS_TO_MPH).toFixed(1) : "0.0";
            document.getElementById('elev-val').innerText = altitude ? Math.round(altitude * METERS_TO_FEET) : "0";
            document.getElementById('status').innerText = `GPS: ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
            
            userMarker.setLatLng([lat, lng]);
            if (isFollowing) map.panTo([lat, lng]);
            
            breadcrumbs.push({ lat, lng, time: Date.now() });
            breadcrumbs = breadcrumbs.filter(b => Date.now() - b.time < 300000);
            trailLine.setLatLngs(breadcrumbs.map(b => [b.lat, b.lng]));

            if (routeGeoJson) {
                const userPt = turf.point([lng, lat]);
                const snapped = turf.nearestPointOnLine(routeGeoJson, userPt, {units: 'miles'});
                const distFromRouteFeet = turf.distance(userPt, snapped, {units: 'miles'}) * 5280;

                if (distFromRouteFeet <= FEET_LIMIT) {
                    if (!map.hasLayer(snappedMarker)) snappedMarker.addTo(map);
                    currentDist = snapped.properties.location;
                    const sElev = snapped.geometry.coordinates[2] || 0;
                    snappedMarker.setLatLng([snapped.geometry.coordinates[1], snapped.geometry.coordinates[0]]);
                    chart.data.datasets[1].data = [{ x: currentDist, y: sElev }];

                    const lookAheadMi = 0.031; 
                    const aheadDist = Math.min(totalDist, currentDist + lookAheadMi);
                    const pAhead = turf.along(routeGeoJson, aheadDist, {units: 'miles'});
                    const elevAhead = pAhead.geometry.coordinates[2] || 0;
                    const runFeet = (aheadDist - currentDist) * 5280;
                    const riseFeet = elevAhead - sElev;
                    
                    let grade = (runFeet > 2) ? (riseFeet / runFeet) * 100 : 0;
                    document.getElementById('grade-val').innerText = grade.toFixed(1);
                    document.getElementById('remain-val').innerText = Math.max(0, totalDist - currentDist).toFixed(1);

                    const gBox = document.getElementById('grade-box');
                    // Data box color also updated to match new logic
                    if (grade >= 6) gBox.style.background = 'rgba(231, 76, 60, 0.4)';
                    else if (grade >= 3) gBox.style.background = 'rgba(241, 196, 15, 0.4)';
                    else gBox.style.background = 'rgba(255, 255, 255, 0.3)';

                    updateChartWindow();
                } else {
                    if (map.hasLayer(snappedMarker)) map.removeLayer(snappedMarker);
                    chart.data.datasets[1].data = [];
                    chart.update('none');
                    document.getElementById('grade-val').innerText = "0.0";
                    document.getElementById('remain-val').innerText = "0.0";
                    document.getElementById('grade-box').style.background = 'rgba(255, 255, 255, 0.3)';
                }
            }
        }, null, { enableHighAccuracy: true });
        
        if ('wakeLock' in navigator) { navigator.wakeLock.request('screen').catch(() => {}); }
    }
    window.onload = init;
</script>
</body>
</html>
